{"ast":null,"code":"import { Observable } from 'rxjs';\nconst fetch = (req, httpClient, extractFiles) => {\n  const shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;\n  const shouldStringify = param => ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;\n  const isBatching = req.body.length;\n  let shouldUseMultipart = req.options && req.options.useMultipart;\n  let multipartInfo;\n  if (shouldUseMultipart) {\n    if (isBatching) {\n      return new Observable(observer => observer.error(new Error('File upload is not available when combined with Batching')));\n    }\n    if (!shouldUseBody) {\n      return new Observable(observer => observer.error(new Error('File upload is not available when GET is used')));\n    }\n    multipartInfo = extractFiles(req.body);\n    shouldUseMultipart = !!multipartInfo.files.size;\n  }\n  // `body` for some, `params` for others\n  let bodyOrParams = {};\n  if (isBatching) {\n    if (!shouldUseBody) {\n      return new Observable(observer => observer.error(new Error('Batching is not available for GET requests')));\n    }\n    bodyOrParams = {\n      body: req.body\n    };\n  } else {\n    const body = shouldUseMultipart ? multipartInfo.clone : req.body;\n    if (shouldUseBody) {\n      bodyOrParams = {\n        body\n      };\n    } else {\n      const params = Object.keys(req.body).reduce((obj, param) => {\n        const value = req.body[param];\n        obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;\n        return obj;\n      }, {});\n      bodyOrParams = {\n        params: params\n      };\n    }\n  }\n  if (shouldUseMultipart && shouldUseBody) {\n    const form = new FormData();\n    form.append('operations', JSON.stringify(bodyOrParams.body));\n    const map = {};\n    const files = multipartInfo.files;\n    let i = 0;\n    files.forEach(paths => {\n      map[++i] = paths;\n    });\n    form.append('map', JSON.stringify(map));\n    i = 0;\n    files.forEach((_, file) => {\n      form.append(++i + '', file, file.name);\n    });\n    bodyOrParams.body = form;\n  }\n  // create a request\n  return httpClient.request(req.method, req.url, Object.assign(Object.assign({\n    observe: 'response',\n    responseType: 'json',\n    reportProgress: false\n  }, bodyOrParams), req.options));\n};\nconst mergeHeaders = (source, destination) => {\n  if (source && destination) {\n    const merged = destination.keys().reduce((headers, name) => headers.set(name, destination.getAll(name)), source);\n    return merged;\n  }\n  return destination || source;\n};\nfunction prioritize(...values) {\n  const picked = values.find(val => typeof val !== 'undefined');\n  if (typeof picked === 'undefined') {\n    return values[values.length - 1];\n  }\n  return picked;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { fetch, mergeHeaders, prioritize };","map":{"version":3,"names":["Observable","fetch","req","httpClient","extractFiles","shouldUseBody","indexOf","method","toUpperCase","shouldStringify","param","toLowerCase","isBatching","body","length","shouldUseMultipart","options","useMultipart","multipartInfo","observer","error","Error","files","size","bodyOrParams","clone","params","Object","keys","reduce","obj","value","JSON","stringify","form","FormData","append","map","i","forEach","paths","_","file","name","request","url","assign","observe","responseType","reportProgress","mergeHeaders","source","destination","merged","headers","set","getAll","prioritize","values","picked","find","val"],"sources":["C:/Users/Arvind/Documents/RogersInterviewDemo2/angular/node_modules/apollo-angular-link-http/node_modules/apollo-angular-link-http-common/__ivy_ngcc__/fesm2015/ngApolloLinkHttpCommon.js"],"sourcesContent":["import { Observable } from 'rxjs';\n\nconst fetch = (req, httpClient, extractFiles) => {\n    const shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;\n    const shouldStringify = (param) => ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;\n    const isBatching = req.body.length;\n    let shouldUseMultipart = req.options && req.options.useMultipart;\n    let multipartInfo;\n    if (shouldUseMultipart) {\n        if (isBatching) {\n            return new Observable(observer => observer.error(new Error('File upload is not available when combined with Batching')));\n        }\n        if (!shouldUseBody) {\n            return new Observable(observer => observer.error(new Error('File upload is not available when GET is used')));\n        }\n        multipartInfo = extractFiles(req.body);\n        shouldUseMultipart = !!multipartInfo.files.size;\n    }\n    // `body` for some, `params` for others\n    let bodyOrParams = {};\n    if (isBatching) {\n        if (!shouldUseBody) {\n            return new Observable(observer => observer.error(new Error('Batching is not available for GET requests')));\n        }\n        bodyOrParams = {\n            body: req.body,\n        };\n    }\n    else {\n        const body = shouldUseMultipart ? multipartInfo.clone : req.body;\n        if (shouldUseBody) {\n            bodyOrParams = {\n                body,\n            };\n        }\n        else {\n            const params = Object.keys(req.body).reduce((obj, param) => {\n                const value = req.body[param];\n                obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;\n                return obj;\n            }, {});\n            bodyOrParams = { params: params };\n        }\n    }\n    if (shouldUseMultipart && shouldUseBody) {\n        const form = new FormData();\n        form.append('operations', JSON.stringify(bodyOrParams.body));\n        const map = {};\n        const files = multipartInfo.files;\n        let i = 0;\n        files.forEach(paths => {\n            map[++i] = paths;\n        });\n        form.append('map', JSON.stringify(map));\n        i = 0;\n        files.forEach((_, file) => {\n            form.append(++i + '', file, file.name);\n        });\n        bodyOrParams.body = form;\n    }\n    // create a request\n    return httpClient.request(req.method, req.url, Object.assign(Object.assign({ observe: 'response', responseType: 'json', reportProgress: false }, bodyOrParams), req.options));\n};\nconst mergeHeaders = (source, destination) => {\n    if (source && destination) {\n        const merged = destination\n            .keys()\n            .reduce((headers, name) => headers.set(name, destination.getAll(name)), source);\n        return merged;\n    }\n    return destination || source;\n};\nfunction prioritize(...values) {\n    const picked = values.find(val => typeof val !== 'undefined');\n    if (typeof picked === 'undefined') {\n        return values[values.length - 1];\n    }\n    return picked;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { fetch, mergeHeaders, prioritize };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}